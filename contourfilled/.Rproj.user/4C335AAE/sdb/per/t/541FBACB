{
    "collab_server" : "",
    "contents" : "#' Makes filled contour plot without sidebar, essentially filled.contour function\n#' @param x  x values, must form grid with y\n#' @param y  y values, must form grid with x\n#' @param z  z values at grid locations\n#' @param xlim  x limits for the plot.\n#' @param ylim  y limits for the plot.\n#' @param zlim  z limits for the plot.\n#' @param levels  a set of levels which are used to partition the range of z. Must be strictly increasing (and finite). Areas with z values between consecutive levels are painted with the same color.\n#' @param nlevels  if levels is not specified, the range of z, values is divided into approximately this many levels.\n#' @param color.palette  a color palette function to be used to assign colors in the plot.\n#' @param col  an explicit set of colors to be used in the plot. This argument overrides any palette function specification. There should be one less color than levels\n#' @param plot.title  statements which add titles to the main plot.\n#' @param plot.axes  statements which draw axes (and a box) on the main plot. This overrides the default axes.\n#' @param key.title  statements which add titles for the plot key.\n#' @param key.axes  statements which draw axes on the plot key. This overrides the default axis.\n#' @param asp  the y/x aspect ratio, see plot.window.\n#' @param xaxs  the x axis style. The default is to use internal labeling.\n#' @param yaxs  the y axis style. The default is to use internal labeling.\n#' @param las  the style of labeling to be used. The default is to use horizontal labeling.\n#' @param axes  logical indicating if axes should be drawn, as in plot.default.\n#' @param frame.plot  logical indicating if a box should be drawn, as in plot.default.\n#' @param ...  additional graphical parameters, currently only passed to title().\n#' @importFrom grDevices cm.colors\n#' @importFrom graphics .filled.contour\n#' @importFrom graphics Axis \n#' @importFrom graphics box\n#' @importFrom graphics plot.new \n#' @importFrom graphics plot.window \n#' @importFrom graphics points \n#' @importFrom graphics title\n#' @examples \n#' x <- y <- seq(-4*pi, 4*pi, len = 27)\n#' r <- sqrt(outer(x^2, y^2, \"+\"))\n#' contourfilled(cos(r^2)*exp(-r/(2*pi)))\n#' @references\n#' [1] filled.contour R function, copied function but removed part for sidebar\n#' @references\n#' [2] http://stackoverflow.com/questions/16774928/removing-part-of-a-graphic-in-r, answer by P Lapointe\n#' @export\ncontourfilled <-\n  function (x = seq(0, 1, length.out = nrow(z)), \n            y = seq(0, 1,length.out = ncol(z)), z, xlim = range(x, finite = TRUE),\n            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE),\n            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors,\n            col = color.palette(length(levels) - 1), plot.title, plot.axes,\n            key.title, key.axes, asp = NA, xaxs = \"i\", yaxs = \"i\", las = 1,\n            axes = TRUE, frame.plot = axes, ...)\n  {\n    # filled.contour gives unnecessary legend, this function removes it\n    # Used P Lapointe's solution from here: http://stackoverflow.com/questions/16774928/removing-part-of-a-graphic-in-r\n    #   also had to changed .Internal(fillcontour) to .filled.contour\n    #   and change layout to layout(matrix(c(1, 1), ncol = 1L), widths = c(1, lcm(w)))\n    # Created 3/28/16 by Collin Erickson\n    if (missing(z)) {\n      if (!missing(x)) {\n        if (is.list(x)) {\n          z <- x$z\n          y <- x$y\n          x <- x$x\n        }\n        else {\n          z <- x\n          x <- seq.int(0, 1, length.out = nrow(z))\n        }\n      }\n      else stop(\"no 'z' matrix specified\")\n    }\n    else if (is.list(x)) {\n      y <- x$y\n      x <- x$x\n    }\n    if (any(diff(x) <= 0) || any(diff(y) <= 0))\n      stop(\"increasing 'x' and 'y' values expected\")\n    #mar.orig <- (par.orig <- par(c(\"mar\", \"las\", \"mfrow\")))$mar\n    #on.exit(par(par.orig))\n    # Comment out everything that was for legend\n    #w <- (3 + mar.orig[2L]) * par(\"csi\") * 2.54\n    #layout(matrix(c(1, 1), ncol = 1L), widths = c(1, lcm(w)))\n    #par(las = las)\n    #mar <- mar.orig\n    #mar[4L] <- mar[2L]\n    #mar[2L] <- 1\n    #par(mar = mar)\n    #plot.new()\n    #plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = \"i\",\n    #            yaxs = \"i\")\n    #    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)\n    #    if (missing(key.axes)) {\n    #        if (axes)\n    #            axis(4)\n    #    }\n    #    else key.axes\n    #    box()\n    #if (!missing(key.title))\n    #  key.title\n    #mar <- mar.orig\n    #mar[4L] <- 1\n    #par(mar = mar)\n    # Changing the margin to get bigger and square\n    mar <- mar.orig <- par()$mar\n    mar[1] <- 2.2 # bottom\n    mar[2] <- 2.5 # left\n    mar[3] <- 1.3 # top\n    mar[4] <- 1 # right\n    par(mar = mar)\n    plot.new()\n    plot.window(xlim, ylim, \"\", xaxs = xaxs, yaxs = yaxs, asp = asp)\n    if (!is.matrix(z) || nrow(z) <= 1L || ncol(z) <= 1L)\n      stop(\"no proper 'z' matrix specified\")\n    if (!is.double(z))\n      storage.mode(z) <- \"double\"\n    #.Internal(filledcontour(as.double(x), as.double(y), z, as.double(levels),\n    #                        col = col))\n    .filled.contour(as.double(x), as.double(y), z, as.double(levels),\n                    col = col)\n    if (missing(plot.axes)) {\n      if (axes) {\n        title(main = \"\", xlab = \"\", ylab = \"\")\n        Axis(x, side = 1)\n        Axis(y, side = 2)\n      }\n    }\n    else plot.axes\n    if (frame.plot)\n      box()\n    if (missing(plot.title))\n      title(...)\n    else plot.title\n    invisible()\n}\n#' Makes filled contour plot from function without sidebar, uses contourfilled\n#' @param fn0  function to plot, first argument must be two-dimensional\n#' @param n  number of points in each dimension\n#' @param xcontlim  x limits for the contour plot\n#' @param ycontlim  y limits for the contour plot\n#' @param mainminmax  whether the min and max values should be shown in the title of plot\n#' @param batchmax  number of datapoints that can be computed at a time\n#' @param out.col.name  if a column needs to be selected from the function, specify it\n#' @param ...  Passed to contourfilled\n#' @examples \n#' contourfilled.func(function(x){x[1]*x[2]})\n#' contourfilled.func(function(x)(exp(-(x[1]-.5)^2-5*(x[2]-.5)^2)))\n#' @references\n#' [1] filled.contour R function, copied function but removed part for sidebar\n#' @references\n#' [2] http://stackoverflow.com/questions/16774928/removing-part-of-a-graphic-in-r, answer by P Lapointe\n#' @export\ncontourfilled.func <- function(fn0,n=100,xcontlim=c(0,1),ycontlim=c(0,1),mainminmax=T,batchmax=1,out.col.name=NULL,...) {\n  if(is.null(out.col.name)) {fn <- fn0} else {fn <- function(xx){fn0(xx)[,out.col.name]}}\n  x <- seq(xcontlim[1],xcontlim[2],length.out = n)\n  y <- seq(ycontlim[1],ycontlim[2],length.out = n)\n  z <- matrix(NA,n,n)\n  if(batchmax<=1) { # calculate single Z value at a time\n    for(xi in 1:n) for(yi in 1:n) {z[xi,yi] <- fn(c(x[xi],y[yi]))}\n  } else {\n    inbatch <- 0\n    for(xi in 1:n) {\n      for(yi in 1:n) {\n        if(inbatch==0) XYi <- matrix(c(xi,yi),ncol=2)\n        else XYi <- rbind(XYi,matrix(c(xi,yi),ncol=2))\n        inbatch <- inbatch + 1\n        if(inbatch == batchmax | (xi==n & yi==n)) {\n          Zbatch <- fn(matrix(c(x[XYi[,1]],y[XYi[,2]]),ncol=2,byrow=F))\n          for(rowbatch in 1:length(Zbatch)) {\n            z[XYi[rowbatch,1],XYi[rowbatch,2]] <- Zbatch[rowbatch]\n          }\n          inbatch <- 0\n          rm(XYi)\n        }\n      }\n    }\n  }\n  if(mainminmax) {\n    #contourfilled(x,y,z,main=paste('min = ',signif(min(z),3),', max = ',signif(max(z),3)),...)\n    #contourfilled(x,y,z,main=paste('(min, max) = (',signif(min(z),3),', ',signif(max(z),3),')'),...)\n    contourfilled(x,y,z)\n    multicolor.title(c('(','min',', ','max',') = (',signif(min(z),3),', ',signif(max(z),3),')'),c(1,\"#80FFFFFF\",1,\"#FF80FFFF\",1,1,1,1,1))\n    #contourfilled(x,y,z,main=paste('abcde','abc'),...)\n  } else {\n    contourfilled(x,y,z,...)\n  }\n}\n#' Makes filled contour plot from data without sidebar by interpolating with Gaussian process, uses contourfilled\n#' @param x  either just x data, x and y data, or x, y and z data\n#' @param y  either y data, z data, or null\n#' @param z  either z data or null\n#' @param xcontlim  x limits for the contour plot\n#' @param ycontlim  y limits for the contour plot\n#' @param ...  passed to contourfilled.func\n#' @importFrom mlegp mlegp\n#' @importFrom mlegp predict.gp\n#' @examples \n#' x <- runif(20)\n#' y <- runif(20)\n#' z <- exp(-(x-.5)^2-5*(y-.5)^2)\n#' contourfilled.data(x,y,z)\n#' @references\n#' [1] filled.contour R function, copied function but removed part for sidebar\n#' @references\n#' [2] http://stackoverflow.com/questions/16774928/removing-part-of-a-graphic-in-r, answer by P Lapointe\n#' @export\ncontourfilled.data <- function(x,y=NULL,z=NULL,xcontlim=NULL,ycontlim=NULL,...) {\n  # Function that creates a contour plot from a data set\n  # using a Gaussian process interpolation from mlegp\n  #  x,y,z: three dimensional data, can be given only in x, in x and y, or in all three\n  #  xcontlim,ycontlim: contour limits will be set to data limits +- 5% if not specified\n  #  ... parameters passed to contourfilled.func\n  # Created 5/23/16 by Collin Erickson\n  #require(mlegp)\n  # This section parses data into x, y, and z\n  if (is.null(y) & !is.null(z)) {\n    if(dim(x)[2]!=2) {stop('Either give y or x must be matrix')}\n    y <- x[,2]\n    x <- x[,1]\n  } else if (!is.null(y) & is.null(z)) {\n    if(dim(x)[2]!=2) {stop('Either give y or x must be matrix')}\n    z <- y\n    y <- x[,2]\n    x <- x[,1]\n  } else if (is.null(y) & is.null(z)) {\n    if (dim(x)[2]!=3) {stop('If only giving x it must have three columns')}\n    z <- x[,3]\n    y <- x[,2]\n    x <- x[,1]\n  }\n  # Fits a Gaussian process model that interpolates perfectly\n  mod <- mlegp::mlegp(X=data.frame(x,y),Z=z,verbose=0)\n  pred.func <- function(xx) {mlegp::predict.gp(mod,xx)}\n  minx <- min(x);maxx <- max(x);miny <- min(y);maxy <- max(y)\n  if(is.null(xcontlim)) {xcontlim <- c(minx-.05*(maxx-minx),maxx+.05*(maxx-minx))}\n  if(is.null(ycontlim)) {ycontlim <- c(miny-.05*(maxy-miny),maxy+.05*(maxy-miny))}\n  # Passes prediction function to contourfilled.func\n  contourfilled.func(fn0 = pred.func,xcontlim=xcontlim,ycontlim=ycontlim,...)\n  # Adds points to show where data came from\n  points(x,y,pch=19)\n}\n\n#' Makes plot title using specified colors for the text\n#' @param main  Text to put in main title of plot\n#' @param col.main  Colors to use for the text\n#' @param collapse  What to put between elements of main, defaults to \"\" but \" \" might be appropriate\n#' @examples \n#' plot(1:4)\n#' multicolor.title(c('Black, ','red, ','green'),c(1,2,3))\n#' @export\nmulticolor.title <- function(main,col.main,collapse='') {\n  if (length(main) != length(col.main)) {stop('main and col must have same length')}\n  n <- length(main)\n  if(n==1) {print('n is 1')\n    title(bquote(.(main[1])),col.main=col.main[1])\n  } else {\n    # print first\n    title(bquote(.(main[1]) * phantom(.(paste0(main[2:n],collapse=collapse)))),col.main=col.main[1])\n    \n    # print middle\n    if(n > 2) {\n      for(i in 2:(n-1)) {\n        title(bquote(phantom(.(paste0(main[1:(i-1)],collapse=collapse))) * .(main[i]) * phantom(.(paste0(main[(i+1):n],collapse=collapse)))),col.main=col.main[i]) \n      }\n    }\n    \n    # print last\n    title(bquote(phantom(.(paste0(main[1:(n-1)],collapse=collapse))) * .(main[n])),col.main=col.main[n])\n  }\n}",
    "created" : 1464033507180.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2233446807",
    "id" : "541FBACB",
    "lastKnownWriteTime" : 1467690937,
    "last_content_update" : 1467690937,
    "path" : "C:/Users/cbe117/School/DOE/Codes/contour/contourfilled/R/contourfilled.R",
    "project_path" : "R/contourfilled.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}